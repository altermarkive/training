\documentclass{slides}
\usepackage[utf8]{inputenc}
\usepackage[a4paper,landscape,margin=1cm]{geometry}
\usepackage{lmodern}
\usepackage{fp}
\usepackage{amsmath}
\usepackage{xypic}
\usepackage{listings}
\usepackage{hyperref}

\newcommand{\sizedfont}[1]{
\FPeval\size{1.1*#1}
\fontsize{#1}{\size}\selectfont
}

\newcommand{\flashcard}[3]{
\sizedfont{#1}
\vspace*{\fill}
\begin{#2}
#3
\end{#2}
\vspace*{\fill}
\pagebreak
}

\begin{document}

\setlength{\itemsep}{0cm}
\setlength{\parskip}{0cm}
\fontfamily{lmss}\selectfont

\pagenumbering{gobble}

\flashcard{60}{center}{
DYNAMIC PROGRAMMING
}
\flashcard{46}{center}{
TOP-DOWN: MEMOIZATION\linebreak
\linebreak
\linebreak
BOTTOM-UP: SUBPROBLEMS (TABULAR FORM)
}

\flashcard{60}{center}{
DFS vs. BFS
}
\flashcard{40}{center}{
WORST CASE \( O(B^D) \)\linebreak
DFS: RECURSIVE vs. BFS: FIFO\linebreak
(DFS MAY OVERFLOW THE STACK)\linebreak
PRE-ORDER: VISIT ROOT\linebreak
IN-ORDER: LEFT, ROOT, RIGHT\linebreak
POST-ORDER: VISIT CHILDREN
}

\flashcard{60}{center}{
HASH TABLES
}
\flashcard{32}{flushleft}{
\begin{description}
\item[FLOAT:] \( \frac{KEY - MIN}{MAX - MIN}\mod{M} \)\linebreak
\item[INT:] \( KEY\mod{M} \) where \( \left\{M: \text{MERSENNE PRIME}\right\} \) \linebreak\% IMPL. CAN BE FAST\linebreak
\item[STRING:] \( (\sum{str[i] << b})\mod{M} \) \linebreak b - NUMBER OF CHARACTER CODING BITS\linebreak
\end{description}
RESOLUTION (constant if enough buckets, linear within a bucket):
\begin{itemize}
\item SEPARATE CHAINING (LISTS)\linebreak(A.K.A. OPEN HASHING, CLOSED ADDRESSING)
\item LINEAR PROBING (ARRAY)\linebreak(A.K.A. CLOSED HASHING, OPEN ADDRESSING)
\end{itemize}
}

\flashcard{52}{center}{
HEAPS\linebreak
(Java: PriorityQueue)\linebreak
\href{https://www.hackerrank.com/challenges/qheap1}{hackerrank.com/challenges/qheap1}\linebreak
\href{https://leetcode.com/problems/min-stack/}{https://leetcode.com/problems/min-stack/}\linebreak
\href{https://leetcode.com/problems/kth-largest-element-in-an-array/}{https://leetcode.com/problems/kth-largest-element-in-an-array/}\linebreak
}
\flashcard{32}{flushleft}{
\( \mbox{CHILD} = \mbox{INDEX}^{'} \times 2 \) \linebreak
\( \mbox{PARENT} = \mbox{INDEX}^{'} / 2 \) \linebreak
\linebreak
BUILD: for each index from last parent to 0 (the root) traverse down picking the biggest/smallest child and correcting parent-child order\linebreak
INSERT: append to the end of the array and traverse up correcting parent-child order \( O(\log{n})^{"} \) \linebreak
DELETE: overwrite the node with the last and depending on comparing with its parent either traverse up or down \( O(\log{n})^{"} \) \linebreak
SEARCH: linear scan through the array \( O(n)^{"} \) \linebreak
\linebreak
') correct index by 1 for 0-based array \linebreak
") WORST/AVG
}

\flashcard{60}{center}{
HEAPS\linebreak
(USAGE)
}
\flashcard{42}{center}{
\textbf{RUNNING MEDIAN} - GREATER (SMALLER) HALF OF THE NUMBERS IN MIN (MAX) HEAP; INSERT INCOMING INTO HEAP DEPENDING ON COMPARISON WITH CURRENT MEDIAN; REBALANCE IF NECESSARY; MEDIAN IS ONE OF ROOTS OR THEIR AVERAGE; REMOVE OUTGOING SIMILAR
}

\flashcard{60}{center}{
GRAPHS
}
\flashcard{40}{flushleft}{
\textbf{ADJACENCY MATRIX}\linebreak
PRO: LOOKUP TIME (MANY CONNECTIONS)\linebreak
CON: SIZE (ALL POSSIBLE CONNECTIONS)\linebreak
\textbf{ADJACENCY LIST}\linebreak
PRO: SIZE, SPEED (FEW CONNECTIONS), SPARSE\linebreak
\textbf{SPACE TRADEOFF} \( X \times E > \frac{N^2}{8} \)\linebreak
(X - pointer size in bytes; matrix is packed - 8 booleans per byte)\linebreak
\textbf{OBJECTS \& POINTERS}
}

\flashcard{60}{center}{
TRIE TREE
}
\flashcard{44}{center}{
reTRIEval, PREFIX TREE\linebreak
(MARKOV CHAIN TXT GEN, AUTOCOMPLETE)\linebreak
EXAMPLE: For autocomplete as you build the trie add a flag to each node, indicating if this character is a terminating one.
}

\flashcard{60}{center}{
SELF-BALANCING BST
}

\flashcard{36}{center}{
Java - red-black tree: TreeMap\linebreak
Other algorithm: AVL tree (uses rotation)
}

\flashcard{60}{center}{
QUICK SORT
}
\flashcard{40}{flushleft}{
\begin{itemize}
\item (\textbf{shuffle} first or sample for pivot - median as pivot helps; \href{https://leetcode.com/problems/shuffle-an-array/}{https://leetcode.com/problems/shuffle-an-array/})
\item PICK PIVOT
\item REORDER W.R.T. PIVOT
\item APPLY TO ARRAYS SEPARATED BY PIVOT
\end{itemize}
\ \\
UNSTABLE\linebreak
WORST \( O(N^2) \) \textbf{!!!}\linebreak
BEST \( O(N\log{N}) \)\linebreak
AVERAGE \( O(N\log{N}) \)
}

\flashcard{60}{center}{
MERGE SORT
}
\flashcard{44}{flushleft}{
\begin{itemize}
\item DIVIDE INTO SUBLISTS
\item SORT SUBLISTS RECURSIVELY
\item MERGE SUBLISTS
\end{itemize}
\ \\
STABLE\linebreak
WORST \( O(N\log{N}) \) \textbf{!!!}\linebreak
BEST \( O(N\log{N}) \)\linebreak
AVERAGE \(O(N\log{N}) \)
}

\flashcard{60}{center}{
MINIMUM SPANNING TREE
}
\flashcard{40}{flushleft}{
EXAMPLE \textbf{PRIM'S ALGORITHM}
\begin{enumerate}
\item CREATE TREE WITH ONE RANDOM VERTEX
\item CREATE SET OF ALL EDGES
\item LOOP TILL EVERY EDGE USED
\begin{enumerate}
\item USE AN EDGE WITH SMALLEST WEIGHT CONNECTING VERTEX IN THE TREE TO VERTEX NOT YET IN THE TREE
\end{enumerate}
\end{enumerate}
\ \linebreak
\(  O((|E| + |V|)\log|V|) \) WITH BINARY HEAP \& ADJACENCY
}

\flashcard{60}{center}{
DIJKSTRA'S ALGORITHM\linebreak
(BUT FLOYD ON NEGATIVE)
}
\flashcard{38}{flushleft}{
SHORTEST PATH \( O(|V|^2) \):
\begin{enumerate}
\item FOREACH 0 IF INITIAL, \(\infty\) OTHERWISE (DISTANCE)
\item MARK ALL UNVISITED; INITIAL AS CURRENT
\item BREADTH FIRST; FOR EACH CHILD ITS DISTANCE AND OVERWRITE IF LESS
\item LOWEST DISTANCE UNVISITED NODE AS CURRENT
\item END WHEN ALL VISITED
\end{enumerate}
\ \linebreak
\( O((|E| + |V|)\log|V|) \) WITH A PRIORITY QUEUE (SELF-BALANCING BST OR BINARY HEAP)
}

\flashcard{60}{center}{
LEADER ELECTION
}
\flashcard{48}{center}{
\textbf{LELANN-CHANG-ROBERTS}\linebreak
ONLY FORWARD LARGER ID IF HAVE NOT SENT OWN\linebreak
TIME \( O(N) \)\linebreak
AVG. MESSAGE \( O(N\log{N}) \)\linebreak
WORST MESSAGE \(O(N^2) \)\linebreak
\textbf{HIRSCHBERG-SINCLAIR} ELECTION IN NEIGHBORHOOD\linebreak
WORST MESSAGE \( O(N\log{N}) \)
}

\flashcard{60}{center}{
P VS. NP\linebreak
COMPLETE
}
\flashcard{34}{flushleft}{
\textbf{P}: SOLUTION FOUND IN POLYNOMIAL TIME\linebreak
\textbf{NP}: SOLUTION VERIFIABLE IN POLYNOMIAL TIME\linebreak
\textbf{COMPLETE}: IF ANY PROBLEM IN THAT CLASS CAN BE REDUCED TO IT\linebreak
\textbf{HARD}: IF PROBLEM ALLOWS QUICKLY SOLVE ANY PROBLEM IN THE CLASS\linebreak
\ \\
\(P \neq NP\): \(P \subset NP \), \(NP-COMPLETE \equiv NP \cap NP-HARD\)
}

\flashcard{60}{center}{
NP-COMPLETE PROBLEMS
}
\flashcard{42}{center}{
GRAPH COLORING\linebreak
TRAVELING SALESMAN\linebreak
KNAPSACK PROBLEM\linebreak
BOOLEAN SATISFIABILITY\linebreak
GRAPH ISOMORPHISM\linebreak
SET COVER PROBLEM
}

\flashcard{52}{center}{
UNBOUNDED KNAPSACK PROBLEM\linebreak
\href{http://www.hackerrank.com/challenges/unbounded-knapsack}{hackerrank.com/challenges/unbounded-knapsack}
}
\flashcard{38}{center}{
USE ANY ITEM FROM SET\linebreak
UNBOUNDED - SAME ITEM CAN BE USED \(>\) ONCE\linebreak
MAXIMIZE THE VALUE SUM BUT KEEP WEIGHT UP TO A LIMIT\linebreak
SOLUTION: BOTTOM-UP DYN. PROG\linebreak
\ \\
PSEUDO POLYNOMIAL TIME (LIKE TESTING IF N IS PRIME) - EXP. IN LENGTH (NUMBER OF DIGITS) OF INPUT; POLY. IN NUMERIC VALUE OF INPUT
}

\flashcard{60}{center}{
SET COVER PROBLEM
}
\flashcard{40}{center}{
FROM SET OF SETS SELECT SMALLEST NUMBER OF SETS COVERING UNION\linebreak
\ \\
GREEDY (CHOOSE ONE COVERING MOST)
}

\flashcard{60}{center}{
TRAVELING SALESMAN PROBLEM
}
\flashcard{40}{flushleft}{
\textbf{EXACT ALGORITHM} HELD-KARP \( O(N^22^N) \)\linebreak
\textbf{APPROXIMATE ALGORITHM}
\begin{itemize}
\item \textbf{CONSTRUCTIVE HEURISTICS} GREEDY (NN - 25\% of optimal), MINIMUM SPANNING TREE BASED ALGORITHMS (CHRISTOFIDES ALG.)
\item \textbf{ITERATIVE IMPROVEMENT}
\item \textbf{RANDOM IMPROVEMENT} ANT COLONY OPTIMIZATION
\end{itemize}
}

\flashcard{60}{center}{
PROCESS VS. THREAD\linebreak
CONTEXT SWITCH
}
\flashcard{38}{flushleft}{
\textbf{THREAD}: \underline{PART OF PROCESS}, \underline{SHARED MEMORY}, \underline{ONLY STACK \& REGISTERS SAVED}, CTX SWITCH - SMALLER CACHE IMPACT
\textbf{PROCESS}: \underline{INDEPENDENT}, \underline{SEPARATE MEMORY (MAP)}, STATE / IPC (FILE HANDLES, DEVICE HANDLES, SOCKETS), CTX SWITCH - MEMORY MAP SWITCH, BIGGER CACHE IMPACT (SOME ARCH. MUST FLUSH), POSSIBLY STATE SWITCH, PAGING\linebreak
}

\flashcard{60}{center}{
DEADLOCK\linebreak
VS.\linebreak
LIVELOCK
}
\flashcard{44}{center}{
TWO OR MORE PROCESSES WAIT FOR THE OTHER(S) TO RELEASE THE RESOURCE\linebreak
\ \linebreak
THE STATE DOES CHANGE BUT STILL NO PROGRESS\linebreak
(COURTESY RELEASE)\linebreak
AVOIDANCE BY RANDOMIZATION
}

\flashcard{60}{center}{
LOCKS
}
\flashcard{44}{flushleft}{
SLEEPLOCK - SPINLOCK\linebreak
\linebreak
TEST-AND-SET - FETCH-AND-ADD - CMP-AND-SWAP\linebreak
\linebreak
\textbf{MUTEX}: 2 STATE\linebreak
\textbf{SEMAPHORE}: COUNTS NO OF UNITS OF RESOURCE AVAILABLE\linebreak
\textbf{MONITOR}: OBJ. WHERE METHODS ARE MUTUALLY EXCLUSIVE
}

\flashcard{60}{center}{
DINING PHILOSOPHERS
}
\flashcard{44}{flushleft}{
\begin{itemize}
\item SEMAPHORES / MUTEXES (GRAB FIRST THEN SECOND; RISK: CAN STARVE)
\item CENTRAL MONITOR/WAITER/CONDUCTOR (CAN EAT IF NEITHER NEIGHBOR EATS; RISK: REDUCED PARALLELISM)
\item RESOURCE HIERARCHY (NUMBER FORKS; PICK AND PUT DOWN IN ORDER; RISK: LOW EFFICIENCY)
\end{itemize}
}

\flashcard{60}{center}{
LOCK (JAVA, PYTHON), CONCURRENT
}
\flashcard{44}{center}{
threading.Lock.acquire([blocking])\linebreak
threading.Lock.release([blocking])\linebreak
synchronized\linebreak
\href{https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/package-summary.html}{java.util.concurrent}
}

\flashcard{60}{center}{
SCHEDULING
}
\flashcard{40}{flushleft}{
\begin{itemize}
\item FIFO
\item FIXED PRIORITY PREEMPTIVE (NOT COOPERATIVE)
\item ROUND ROBIN (NO INTERRUPTS)
\item MULTILEVEL FEEDBACK QUEUE: 1. PREFERENCE TO SHORT OR I/O, 2. MULTIPLE FIFO, 3. STARTS AT END OF TOP FIFO, 4. (NORMALLY) TO THE END OF QUEUE (VOLUNTARY), 5. USES UP QUANTUM - PREEMPT AND LOWER QUEUE
\end{itemize}
}

\flashcard{60}{center}{
STRING (JAVA)
}
\flashcard{44}{center}{
compareTo - lexi, ignoreCase, starts, endsWith, equals, indexOf, lastIndexOf, matches - regex, replaceAll - regex, replaceFirst - regex, split, substring, toUpperCase, trim
}

\flashcard{60}{center}{
SORT \& BINARY SEARCH (JAVA)
}
\flashcard{44}{center}{
Arrays\linebreak
Collections.sort(List[, Comparator])\linebreak
int compare(T, T)\linebreak
binarySearch(T[] array, T key)
}

\flashcard{60}{center}{
LISTS (JAVA)
}
\flashcard{44}{center}{
Vector\linebreak
Collections.synchronizedList(List)\linebreak
Where List: ArrayList or LinkedList
}

\flashcard{60}{center}{
\( -\infty \) (JAVA, PYTHON)
}
\flashcard{44}{center}{
Double.NEGATIVE\_INFINITY\linebreak
float('-inf')
}

\flashcard{60}{center}{
SORT (PYTHON)
}
\flashcard{44}{center}{
sorted([...], key=lambda item: item[1], reverse=True)
}

\flashcard{60}{center}{
TCP HANDSHAKE
}
\flashcard{46}{flushleft}{
\begin{itemize}
\item OPEN
\begin{enumerate}
\item \(\rightarrow\) SYN
\item \(\leftarrow\) SYN-ACK
\item \(\rightarrow\) ACK
\end{enumerate}
\item CLOSE
\begin{enumerate}
\item \(\rightarrow\) FIN
\item \(\leftarrow\) ACK
\item \(\leftarrow\) FIN
\item \(\rightarrow\) ACK
\end{enumerate}
\end{itemize}
}

\flashcard{56}{center}{
COMBINATORIAL
}
\flashcard{30}{flushleft}{
\textbf{PERMUTATION}\linebreak
\( N! \) \( \leftarrow \) factorial\linebreak
itertools.permutations(iterable, None)\linebreak
\ \\
\textbf{VARIATION WITHOUT REP.}\linebreak
\( \frac{N!}{(N-K)!} \)\linebreak
itertools.chain.from\_iterable(map(lambda c: itertools.permutations(c), itertools.combinations(iterable, k)))\linebreak
\ \\
\textbf{VARIATION WITH REP. (EQUIVALENT GROUPS REPEAT)}\linebreak
\( N^{K} \)\linebreak
itertools.product(iterable, repeat=k)\linebreak
\ \\
\textbf{COMBINATION}\linebreak
\( \binom{N}{K} \)\linebreak
itertools.combinations(iterable, k)
}

\end{document}